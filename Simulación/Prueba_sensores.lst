CCS PCM C Compiler, Version 4.023, 25097               29-jun-09 00:39

               Filename: C:\Documents and Settings\PJ\Escritorio\SHIVA\Simulación\Prueba_sensores.lst

               ROM used: 1694 words (21%)
                         Largest free fragment is 2048
               RAM used: 57 (15%) at main() level
                         73 (20%) worst case
               Stack:    5 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   4BA
0003:  NOP
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
.................... #list 
....................  
.................... #device adc=10            // Conversor Analogico Digital de 10 bit el PIC 16F876A puede trabajar con 8 o 10 bit de resolucion. 
....................  
.................... #fuses XT,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock= 1000000)         
*
0031:  MOVLW  44
0032:  MOVWF  04
0033:  BCF    03.7
0034:  MOVF   00,W
0035:  BTFSC  03.2
0036:  GOTO   03D
0037:  MOVLW  52
0038:  MOVWF  77
0039:  DECFSZ 77,F
003A:  GOTO   039
003B:  DECFSZ 00,F
003C:  GOTO   037
003D:  RETLW  00
....................  
.................... #include <LCD1.c>            // Incluimos el driver LCD1.c que contiene las funciones de control del LCD. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF82                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 7                 // on to port C (at address 7) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_c(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
004A:  MOVLW  F0
004B:  BSF    03.5
004C:  MOVWF  06
....................       lcd.rw = 1; 
004D:  BCF    03.5
004E:  BSF    06.2
....................       delay_cycles(1); 
004F:  NOP
....................       lcd.enable = 1; 
0050:  BSF    06.0
....................       delay_cycles(1); 
0051:  NOP
....................       high = lcd.data; 
0052:  MOVF   06,W
0053:  SWAPF  06,W
0054:  ANDLW  0F
0055:  MOVWF  58
....................       lcd.enable = 0; 
0056:  BCF    06.0
....................       delay_cycles(1); 
0057:  NOP
....................       lcd.enable = 1; 
0058:  BSF    06.0
....................       delay_us(1); 
....................       low = lcd.data; 
0059:  MOVF   06,W
005A:  SWAPF  06,W
005B:  ANDLW  0F
005C:  MOVWF  57
....................       lcd.enable = 0; 
005D:  BCF    06.0
....................       set_tris_lcd(LCD_WRITE); 
005E:  MOVLW  00
005F:  BSF    03.5
0060:  MOVWF  06
....................       return( (high<<4) | low); 
0061:  BCF    03.5
0062:  SWAPF  58,W
0063:  MOVWF  77
0064:  MOVLW  F0
0065:  ANDWF  77,F
0066:  MOVF   77,W
0067:  IORWF  57,W
0068:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
003E:  SWAPF  58,W
003F:  ANDLW  F0
0040:  MOVWF  77
0041:  MOVLW  0F
0042:  ANDWF  06,W
0043:  IORWF  77,W
0044:  MOVWF  06
....................       delay_cycles(1); 
0045:  NOP
....................       lcd.enable = 1; 
0046:  BSF    06.0
....................       delay_us(2); 
....................       lcd.enable = 0; 
0047:  BCF    06.0
.................... } 
0048:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
0049:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
0069:  MOVF   78,W
006A:  MOVWF  57
006B:  BTFSC  57.7
006C:  GOTO   04A
....................       lcd.rs = address; 
006D:  BTFSS  55.0
006E:  BCF    06.1
006F:  BTFSC  55.0
0070:  BSF    06.1
....................       delay_cycles(1); 
0071:  NOP
....................       lcd.rw = 0; 
0072:  BCF    06.2
....................       delay_cycles(1); 
0073:  NOP
....................       lcd.enable = 0; 
0074:  BCF    06.0
....................       lcd_send_nibble(n >> 4); 
0075:  SWAPF  56,W
0076:  MOVWF  57
0077:  MOVLW  0F
0078:  ANDWF  57,F
0079:  MOVF   57,W
007A:  MOVWF  58
007B:  CALL   03E
....................       lcd_send_nibble(n & 0xf); 
007C:  MOVF   56,W
007D:  ANDLW  0F
007E:  MOVWF  57
007F:  MOVWF  58
0080:  CALL   03E
.................... } 
0081:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
0082:  MOVLW  00
0083:  BSF    03.5
0084:  MOVWF  06
....................     lcd.rs = 0; 
0085:  BCF    03.5
0086:  BCF    06.1
....................     lcd.rw = 0; 
0087:  BCF    06.2
....................     lcd.enable = 0; 
0088:  BCF    06.0
....................     delay_ms(15); 
0089:  MOVLW  0F
008A:  MOVWF  44
008B:  CALL   031
....................     for(i=1;i<=3;++i) { 
008C:  MOVLW  01
008D:  MOVWF  43
008E:  MOVF   43,W
008F:  SUBLW  03
0090:  BTFSS  03.0
0091:  GOTO   09A
....................        lcd_send_nibble(3); 
0092:  MOVLW  03
0093:  MOVWF  58
0094:  CALL   03E
....................        delay_ms(5); 
0095:  MOVLW  05
0096:  MOVWF  44
0097:  CALL   031
....................     } 
0098:  INCF   43,F
0099:  GOTO   08E
....................     lcd_send_nibble(2); 
009A:  MOVLW  02
009B:  MOVWF  58
009C:  CALL   03E
....................     for(i=0;i<=3;++i) 
009D:  CLRF   43
009E:  MOVF   43,W
009F:  SUBLW  03
00A0:  BTFSS  03.0
00A1:  GOTO   0AB
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
00A2:  MOVF   43,W
00A3:  CALL   004
00A4:  MOVWF  44
00A5:  CLRF   55
00A6:  MOVF   44,W
00A7:  MOVWF  56
00A8:  CALL   049
00A9:  INCF   43,F
00AA:  GOTO   09E
.................... } 
00AB:  BCF    0A.3
00AC:  BCF    0A.4
00AD:  GOTO   4D5 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
00B1:  DECFSZ 52,W
00B2:  GOTO   0B4
00B3:  GOTO   0B7
....................      address=lcd_line_two; 
00B4:  MOVLW  40
00B5:  MOVWF  53
....................    else 
00B6:  GOTO   0B8
....................      address=0; 
00B7:  CLRF   53
....................    address+=x-1; 
00B8:  MOVLW  01
00B9:  SUBWF  51,W
00BA:  ADDWF  53,F
....................    lcd_send_byte(0,0x80|address); 
00BB:  MOVF   53,W
00BC:  IORLW  80
00BD:  MOVWF  54
00BE:  CLRF   55
00BF:  MOVF   54,W
00C0:  MOVWF  56
00C1:  CALL   049
.................... } 
00C2:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
00C3:  MOVF   50,W
00C4:  XORLW  0C
00C5:  BTFSC  03.2
00C6:  GOTO   0CE
00C7:  XORLW  06
00C8:  BTFSC  03.2
00C9:  GOTO   0D8
00CA:  XORLW  02
00CB:  BTFSC  03.2
00CC:  GOTO   0DE
00CD:  GOTO   0E3
....................      case '\f'   : lcd_send_byte(0,1); 
00CE:  CLRF   55
00CF:  MOVLW  01
00D0:  MOVWF  56
00D1:  CALL   049
....................                    delay_ms(2); 
00D2:  MOVLW  A6
00D3:  MOVWF  77
00D4:  DECFSZ 77,F
00D5:  GOTO   0D4
00D6:  NOP
....................                                            break; 
00D7:  GOTO   0E9
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
00D8:  MOVLW  01
00D9:  MOVWF  51
00DA:  MOVLW  02
00DB:  MOVWF  52
00DC:  CALL   0B1
00DD:  GOTO   0E9
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
00DE:  CLRF   55
00DF:  MOVLW  10
00E0:  MOVWF  56
00E1:  CALL   049
00E2:  GOTO   0E9
....................      default     : lcd_send_byte(1,c);     break; 
00E3:  MOVLW  01
00E4:  MOVWF  55
00E5:  MOVF   50,W
00E6:  MOVWF  56
00E7:  CALL   049
00E8:  GOTO   0E9
....................    } 
.................... } 
00E9:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <kbd1.c>            // Incluimos el driver kbd1.c que contiene las funciones de control del Teclado. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBDD.C                                //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF82                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 7                 // on to port C (at address 7) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_c(x) 
.................... #endif 
....................  
....................  
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
.................... } 
*
00AE:  BCF    0A.3
00AF:  BCF    0A.4
00B0:  GOTO   4D6 (RETURN)
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
04C3:  BCF    03.5
04C4:  CLRF   20
....................    static short int kbd_down; 
04C5:  BCF    21.0
....................    static char last_key; 
04C6:  CLRF   22
....................    static BYTE col; 
04C7:  CLRF   23
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
....................        switch (col) { 
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
....................                     kbd=~COL0&ALL_PINS; 
....................                     break; 
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
....................                     kbd=~COL1&ALL_PINS; 
....................                     break; 
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
....................                     kbd=~COL2&ALL_PINS; 
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
....................            kbd_down=FALSE; 
....................            kchar=last_key; 
....................            last_key='\0'; 
....................          } 
....................        } else { 
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
....................              if((kbd & ROW0)==0) 
....................                row=0; 
....................              else if((kbd & ROW1)==0) 
....................                row=1; 
....................              else if((kbd & ROW2)==0) 
....................                row=2; 
....................              else if((kbd & ROW3)==0) 
....................                row=3; 
....................              last_key =KEYS[row][col]; 
....................              kbd_down = TRUE; 
....................           } else { 
....................              ++col; 
....................              if(col==3) 
....................                col=0; 
....................           } 
....................        } 
....................       kbd_call_count=0; 
....................    } 
....................   set_tris_kbd(ALL_PINS); 
....................   return(kchar); 
.................... } 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //	float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *(&res) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................       *(&y) = 0x7E; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *(&x) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO	1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI 			0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
.................... 	float y, t, t2 = 1.0; 
.................... 	int quad, i; 
.................... 	float frac; 
.................... 	float p[4] = { 
.................... 		-0.499999993585, 
.................... 		 0.041666636258, 
.................... 		-0.0013888361399, 
.................... 		 0.00002476016134 
.................... 	}; 
....................  
.................... 	if (x < 0) x = -x;                  // absolute value of input 
....................  
.................... 	quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
.................... 	frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
.................... 	quad = quad % 4;                    // quadrant (0 to 3) 
....................  
.................... 	if (quad == 0 || quad == 2) 
.................... 		t = frac * PI_DIV_BY_TWO; 
.................... 	else if (quad == 1) 
.................... 		t = (1-frac) * PI_DIV_BY_TWO; 
.................... 	else // should be 3 
.................... 		t = (frac-1) * PI_DIV_BY_TWO; 
....................  
.................... 	y = 0.999999999781; 
.................... 	t = t * t; 
.................... 	for (i = 0; i <= 3; i++) 
.................... 	{ 
.................... 		t2 = t2 * t; 
.................... 		y = y + p[i] * t2; 
.................... 	} 
....................  
.................... 	if (quad == 2 || quad == 1) 
.................... 		y = -y;  // correct sign 
....................  
.................... 	return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
.................... 	return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
.................... 	if (c == 0.0) 
.................... 	   return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //	float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //	float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #BYTE TRISC = 0x87               // TRISC en 87h. 
.................... #BYTE portC = 0x07               // PORTC en 07h. 
.................... #BYTE TRISA = 0x85               // TRISB en 86h. 
.................... #BYTE portA = 0x05               // PORTB en 06h. 
.................... #BIT rc0 = 0x07.0  
.................... #BIT rc1 = 0x07.1 
.................... #BIT rc2 = 0x07.2 
.................... #BIT rc5 = 0x07.5 
.................... #BIT ra0 = 0x05.0 
.................... #BIT ra1 = 0x05.1 
.................... #BIT ra2 = 0x05.2 
.................... #BIT ra3 = 0x05.3 
.................... #BIT ra4 = 0x05.4 
.................... #BIT ra5 = 0x05.5 
....................  
....................  
....................   
....................  
.................... void main() 
....................  
.................... { 
*
04BA:  CLRF   04
04BB:  BCF    03.7
04BC:  MOVLW  1F
04BD:  ANDWF  03,F
04BE:  BSF    03.5
04BF:  BSF    1F.0
04C0:  BSF    1F.1
04C1:  BSF    1F.2
04C2:  BCF    1F.3
....................    char k;  
....................    int16 q; 
....................    float x; 
....................    float l; 
....................    float p; 
....................    float r; 
....................    float s; 
....................    float i; 
....................    float e; 
....................    TRISC= 0B00000000; 
*
04C8:  BSF    03.5
04C9:  CLRF   07
....................    TRISA= 0B001011; 
04CA:  MOVLW  0B
04CB:  MOVWF  05
....................    portC= 0B00000000; 
04CC:  BCF    03.5
04CD:  CLRF   07
....................     
....................    setup_adc_ports(0100); 
04CE:  BSF    03.5
04CF:  BCF    1F.0
04D0:  BCF    1F.1
04D1:  BCF    1F.2
04D2:  BCF    1F.3
....................    lcd_init();             // Inicializamos el LCD. 
04D3:  BCF    03.5
04D4:  GOTO   082
....................    kbd_init();              // Inicializamos el Teclado. 
04D5:  GOTO   0AE
....................    setup_adc(ADC_CLOCK_INTERNAL);             // Fuente de reloj RC interno. 
04D6:  BSF    1F.6
04D7:  BSF    1F.7
04D8:  BSF    03.5
04D9:  BSF    1F.7
04DA:  BCF    03.5
04DB:  BSF    1F.0
....................    set_adc_channel(0);  
04DC:  MOVLW  00
04DD:  MOVWF  78
04DE:  MOVF   1F,W
04DF:  ANDLW  C7
04E0:  IORWF  78,W
04E1:  MOVWF  1F
....................    port_b_pullups(TRUE);          // Habilitamos las Resistencias pull up inernas en el puerto B 
04E2:  BSF    03.5
04E3:  BCF    01.7
....................    printf(lcd_putc,"Prueb Sensor");  
04E4:  BCF    03.5
04E5:  CLRF   43
04E6:  MOVF   43,W
04E7:  CALL   00C
04E8:  INCF   43,F
04E9:  MOVWF  77
04EA:  MOVWF  50
04EB:  CALL   0C3
04EC:  MOVLW  0C
04ED:  SUBWF  43,W
04EE:  BTFSS  03.2
04EF:  GOTO   4E6
....................    printf(lcd_putc,"\f"); 
04F0:  MOVLW  0C
04F1:  MOVWF  50
04F2:  CALL   0C3
....................   
....................    while(1){ 
....................             lcd_gotoxy(1,1);       
04F3:  MOVLW  01
04F4:  MOVWF  51
04F5:  MOVWF  52
04F6:  CALL   0B1
....................             printf(lcd_putc,"Funcion polinom",);   // Escribimos 1 digitos de la variable "k" en formato caracter. 
04F7:  CLRF   43
04F8:  MOVF   43,W
04F9:  CALL   01D
04FA:  INCF   43,F
04FB:  MOVWF  77
04FC:  MOVWF  50
04FD:  CALL   0C3
04FE:  MOVLW  0F
04FF:  SUBWF  43,W
0500:  BTFSS  03.2
0501:  GOTO   4F8
....................             delay_us(20);               // Retardo de 20uS necesaria para respetar el tiempo de Adquisicion Tad. 
0502:  GOTO   503
0503:  GOTO   504
0504:  NOP
....................             q = read_adc();                        // Lectura canal 0   "AN0" 
0505:  BSF    1F.2
0506:  BTFSC  1F.2
0507:  GOTO   506
0508:  BSF    03.5
0509:  MOVF   1E,W
050A:  BCF    03.5
050B:  MOVWF  25
050C:  MOVF   1E,W
050D:  MOVWF  26
....................             p = 5.0 * q / 1024.0;                 // Conversion a tension del codigo digital "q". 
050E:  MOVF   26,W
050F:  MOVWF  44
0510:  MOVF   25,W
0511:  MOVWF  43
0512:  GOTO   0EA
0513:  CLRF   53
0514:  CLRF   52
0515:  MOVLW  20
0516:  MOVWF  51
0517:  MOVLW  81
0518:  MOVWF  50
0519:  MOVF   7A,W
051A:  MOVWF  57
051B:  MOVF   79,W
051C:  MOVWF  56
051D:  MOVF   78,W
051E:  MOVWF  55
051F:  MOVF   77,W
0520:  MOVWF  54
0521:  CALL   109
0522:  MOVF   77,W
0523:  MOVWF  43
0524:  MOVF   78,W
0525:  MOVWF  44
0526:  MOVF   79,W
0527:  MOVWF  45
0528:  MOVF   7A,W
0529:  MOVWF  46
052A:  MOVWF  4A
052B:  MOVF   79,W
052C:  MOVWF  49
052D:  MOVF   78,W
052E:  MOVWF  48
052F:  MOVF   77,W
0530:  MOVWF  47
0531:  CLRF   4E
0532:  CLRF   4D
0533:  CLRF   4C
0534:  MOVLW  89
0535:  MOVWF  4B
0536:  GOTO   17E
0537:  MOVF   7A,W
0538:  MOVWF  32
0539:  MOVF   79,W
053A:  MOVWF  31
053B:  MOVF   78,W
053C:  MOVWF  30
053D:  MOVF   77,W
053E:  MOVWF  2F
....................             r=p*p; 
053F:  MOVF   32,W
0540:  MOVWF  53
0541:  MOVF   31,W
0542:  MOVWF  52
0543:  MOVF   30,W
0544:  MOVWF  51
0545:  MOVF   2F,W
0546:  MOVWF  50
0547:  MOVF   32,W
0548:  MOVWF  57
0549:  MOVF   31,W
054A:  MOVWF  56
054B:  MOVF   30,W
054C:  MOVWF  55
054D:  MOVF   2F,W
054E:  MOVWF  54
054F:  CALL   109
0550:  MOVF   7A,W
0551:  MOVWF  36
0552:  MOVF   79,W
0553:  MOVWF  35
0554:  MOVF   78,W
0555:  MOVWF  34
0556:  MOVF   77,W
0557:  MOVWF  33
....................             s=p*p*p; 
0558:  MOVF   32,W
0559:  MOVWF  53
055A:  MOVF   31,W
055B:  MOVWF  52
055C:  MOVF   30,W
055D:  MOVWF  51
055E:  MOVF   2F,W
055F:  MOVWF  50
0560:  MOVF   32,W
0561:  MOVWF  57
0562:  MOVF   31,W
0563:  MOVWF  56
0564:  MOVF   30,W
0565:  MOVWF  55
0566:  MOVF   2F,W
0567:  MOVWF  54
0568:  CALL   109
0569:  MOVF   77,W
056A:  MOVWF  43
056B:  MOVF   78,W
056C:  MOVWF  44
056D:  MOVF   79,W
056E:  MOVWF  45
056F:  MOVF   7A,W
0570:  MOVWF  46
0571:  MOVWF  53
0572:  MOVF   79,W
0573:  MOVWF  52
0574:  MOVF   78,W
0575:  MOVWF  51
0576:  MOVF   77,W
0577:  MOVWF  50
0578:  MOVF   32,W
0579:  MOVWF  57
057A:  MOVF   31,W
057B:  MOVWF  56
057C:  MOVF   30,W
057D:  MOVWF  55
057E:  MOVF   2F,W
057F:  MOVWF  54
0580:  CALL   109
0581:  MOVF   7A,W
0582:  MOVWF  3A
0583:  MOVF   79,W
0584:  MOVWF  39
0585:  MOVF   78,W
0586:  MOVWF  38
0587:  MOVF   77,W
0588:  MOVWF  37
....................             i=p*p*p*p;  
0589:  MOVF   32,W
058A:  MOVWF  53
058B:  MOVF   31,W
058C:  MOVWF  52
058D:  MOVF   30,W
058E:  MOVWF  51
058F:  MOVF   2F,W
0590:  MOVWF  50
0591:  MOVF   32,W
0592:  MOVWF  57
0593:  MOVF   31,W
0594:  MOVWF  56
0595:  MOVF   30,W
0596:  MOVWF  55
0597:  MOVF   2F,W
0598:  MOVWF  54
0599:  CALL   109
059A:  MOVF   77,W
059B:  MOVWF  43
059C:  MOVF   78,W
059D:  MOVWF  44
059E:  MOVF   79,W
059F:  MOVWF  45
05A0:  MOVF   7A,W
05A1:  MOVWF  46
05A2:  MOVWF  53
05A3:  MOVF   79,W
05A4:  MOVWF  52
05A5:  MOVF   78,W
05A6:  MOVWF  51
05A7:  MOVF   77,W
05A8:  MOVWF  50
05A9:  MOVF   32,W
05AA:  MOVWF  57
05AB:  MOVF   31,W
05AC:  MOVWF  56
05AD:  MOVF   30,W
05AE:  MOVWF  55
05AF:  MOVF   2F,W
05B0:  MOVWF  54
05B1:  CALL   109
05B2:  MOVF   77,W
05B3:  MOVWF  47
05B4:  MOVF   78,W
05B5:  MOVWF  48
05B6:  MOVF   79,W
05B7:  MOVWF  49
05B8:  MOVF   7A,W
05B9:  MOVWF  4A
05BA:  MOVWF  53
05BB:  MOVF   79,W
05BC:  MOVWF  52
05BD:  MOVF   78,W
05BE:  MOVWF  51
05BF:  MOVF   77,W
05C0:  MOVWF  50
05C1:  MOVF   32,W
05C2:  MOVWF  57
05C3:  MOVF   31,W
05C4:  MOVWF  56
05C5:  MOVF   30,W
05C6:  MOVWF  55
05C7:  MOVF   2F,W
05C8:  MOVWF  54
05C9:  CALL   109
05CA:  MOVF   7A,W
05CB:  MOVWF  3E
05CC:  MOVF   79,W
05CD:  MOVWF  3D
05CE:  MOVF   78,W
05CF:  MOVWF  3C
05D0:  MOVF   77,W
05D1:  MOVWF  3B
....................             e=((16.75*i)-119.26*s)+(311.7*r)-(365.71*p)+184.03; 
05D2:  CLRF   53
05D3:  CLRF   52
05D4:  MOVLW  06
05D5:  MOVWF  51
05D6:  MOVLW  83
05D7:  MOVWF  50
05D8:  MOVF   3E,W
05D9:  MOVWF  57
05DA:  MOVF   3D,W
05DB:  MOVWF  56
05DC:  MOVF   3C,W
05DD:  MOVWF  55
05DE:  MOVF   3B,W
05DF:  MOVWF  54
05E0:  CALL   109
05E1:  MOVF   77,W
05E2:  MOVWF  43
05E3:  MOVF   78,W
05E4:  MOVWF  44
05E5:  MOVF   79,W
05E6:  MOVWF  45
05E7:  MOVF   7A,W
05E8:  MOVWF  46
05E9:  MOVLW  1F
05EA:  MOVWF  53
05EB:  MOVLW  85
05EC:  MOVWF  52
05ED:  MOVLW  6E
05EE:  MOVWF  51
05EF:  MOVLW  85
05F0:  MOVWF  50
05F1:  MOVF   3A,W
05F2:  MOVWF  57
05F3:  MOVF   39,W
05F4:  MOVWF  56
05F5:  MOVF   38,W
05F6:  MOVWF  55
05F7:  MOVF   37,W
05F8:  MOVWF  54
05F9:  CALL   109
05FA:  BSF    03.1
05FB:  MOVF   46,W
05FC:  MOVWF  56
05FD:  MOVF   45,W
05FE:  MOVWF  55
05FF:  MOVF   44,W
0600:  MOVWF  54
0601:  MOVF   43,W
0602:  MOVWF  53
0603:  MOVF   7A,W
0604:  MOVWF  5A
0605:  MOVF   79,W
0606:  MOVWF  59
0607:  MOVF   78,W
0608:  MOVWF  58
0609:  MOVF   77,W
060A:  MOVWF  57
060B:  CALL   24A
060C:  MOVF   77,W
060D:  MOVWF  47
060E:  MOVF   78,W
060F:  MOVWF  48
0610:  MOVF   79,W
0611:  MOVWF  49
0612:  MOVF   7A,W
0613:  MOVWF  4A
0614:  MOVLW  9A
0615:  MOVWF  53
0616:  MOVLW  D9
0617:  MOVWF  52
0618:  MOVLW  1B
0619:  MOVWF  51
061A:  MOVLW  87
061B:  MOVWF  50
061C:  MOVF   36,W
061D:  MOVWF  57
061E:  MOVF   35,W
061F:  MOVWF  56
0620:  MOVF   34,W
0621:  MOVWF  55
0622:  MOVF   33,W
0623:  MOVWF  54
0624:  CALL   109
0625:  BCF    03.1
0626:  MOVF   4A,W
0627:  MOVWF  56
0628:  MOVF   49,W
0629:  MOVWF  55
062A:  MOVF   48,W
062B:  MOVWF  54
062C:  MOVF   47,W
062D:  MOVWF  53
062E:  MOVF   7A,W
062F:  MOVWF  5A
0630:  MOVF   79,W
0631:  MOVWF  59
0632:  MOVF   78,W
0633:  MOVWF  58
0634:  MOVF   77,W
0635:  MOVWF  57
0636:  CALL   24A
0637:  MOVF   77,W
0638:  MOVWF  4B
0639:  MOVF   78,W
063A:  MOVWF  4C
063B:  MOVF   79,W
063C:  MOVWF  4D
063D:  MOVF   7A,W
063E:  MOVWF  4E
063F:  MOVLW  E1
0640:  MOVWF  53
0641:  MOVLW  DA
0642:  MOVWF  52
0643:  MOVLW  36
0644:  MOVWF  51
0645:  MOVLW  87
0646:  MOVWF  50
0647:  MOVF   32,W
0648:  MOVWF  57
0649:  MOVF   31,W
064A:  MOVWF  56
064B:  MOVF   30,W
064C:  MOVWF  55
064D:  MOVF   2F,W
064E:  MOVWF  54
064F:  CALL   109
0650:  BSF    03.1
0651:  MOVF   4E,W
0652:  MOVWF  56
0653:  MOVF   4D,W
0654:  MOVWF  55
0655:  MOVF   4C,W
0656:  MOVWF  54
0657:  MOVF   4B,W
0658:  MOVWF  53
0659:  MOVF   7A,W
065A:  MOVWF  5A
065B:  MOVF   79,W
065C:  MOVWF  59
065D:  MOVF   78,W
065E:  MOVWF  58
065F:  MOVF   77,W
0660:  MOVWF  57
0661:  CALL   24A
0662:  MOVF   77,W
0663:  MOVWF  4F
0664:  MOVF   78,W
0665:  MOVWF  50
0666:  MOVF   79,W
0667:  MOVWF  51
0668:  MOVF   7A,W
0669:  MOVWF  52
066A:  BCF    03.1
066B:  MOVF   7A,W
066C:  MOVWF  56
066D:  MOVF   79,W
066E:  MOVWF  55
066F:  MOVF   78,W
0670:  MOVWF  54
0671:  MOVF   77,W
0672:  MOVWF  53
0673:  MOVLW  AE
0674:  MOVWF  5A
0675:  MOVLW  07
0676:  MOVWF  59
0677:  MOVLW  38
0678:  MOVWF  58
0679:  MOVLW  86
067A:  MOVWF  57
067B:  CALL   24A
067C:  MOVF   7A,W
067D:  MOVWF  42
067E:  MOVF   79,W
067F:  MOVWF  41
0680:  MOVF   78,W
0681:  MOVWF  40
0682:  MOVF   77,W
0683:  MOVWF  3F
....................             lcd_gotoxy(1,2);       
0684:  MOVLW  01
0685:  MOVWF  51
0686:  MOVLW  02
0687:  MOVWF  52
0688:  CALL   0B1
....................             printf(lcd_putc,"L=%01.2f", e);                   
0689:  MOVLW  4C
068A:  MOVWF  50
068B:  CALL   0C3
068C:  MOVLW  3D
068D:  MOVWF  50
068E:  CALL   0C3
068F:  MOVLW  C9
0690:  MOVWF  04
0691:  MOVF   42,W
0692:  MOVWF  46
0693:  MOVF   41,W
0694:  MOVWF  45
0695:  MOVF   40,W
0696:  MOVWF  44
0697:  MOVF   3F,W
0698:  MOVWF  43
0699:  MOVLW  02
069A:  MOVWF  47
069B:  GOTO   3EE
....................              
....................    }                       
069C:  GOTO   4F3
.................... } 
....................  
069D:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
