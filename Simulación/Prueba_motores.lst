CCS PCM C Compiler, Version 4.023, 25097               29-jun-09 00:42

               Filename: Prueba_motores.lst

               ROM used: 433 words (5%)
                         Largest free fragment is 2048
               RAM used: 11 (3%) at main() level
                         21 (6%) worst case
               Stack:    4 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   10D
0003:  NOP
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
.................... #list 
....................  
.................... #device adc=10            // Conversor Analogico Digital de 10 bit el PIC 16F876A puede trabajar con 8 o 10 bit de resolucion. 
....................  
.................... #fuses XT,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock= 1000000)         
0054:  MOVLW  25
0055:  MOVWF  04
0056:  BCF    03.7
0057:  MOVF   00,W
0058:  BTFSC  03.2
0059:  GOTO   060
005A:  MOVLW  52
005B:  MOVWF  77
005C:  DECFSZ 77,F
005D:  GOTO   05C
005E:  DECFSZ 00,F
005F:  GOTO   05A
0060:  RETLW  00
....................  
.................... #include <LCD1.c>            // Incluimos el driver LCD1.c que contiene las funciones de control del LCD. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCDD.C                                //// 
.................... ////                 Driver for common LCD modules                     //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     D0  enable 
.................... //     D1  rs 
.................... //     D2  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC D3 is not used. 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_lcd TRUE 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte lcd = 0xF82                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_lcd 
....................    #byte lcd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte lcd = 7                 // on to port C (at address 7) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_lcd 
....................    #define set_tris_lcd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_lcd(x) set_tris_c(x) 
.................... #endif 
....................  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       set_tris_lcd(LCD_READ); 
*
006D:  MOVLW  F0
006E:  BSF    03.5
006F:  MOVWF  06
....................       lcd.rw = 1; 
0070:  BCF    03.5
0071:  BSF    06.2
....................       delay_cycles(1); 
0072:  NOP
....................       lcd.enable = 1; 
0073:  BSF    06.0
....................       delay_cycles(1); 
0074:  NOP
....................       high = lcd.data; 
0075:  MOVF   06,W
0076:  SWAPF  06,W
0077:  ANDLW  0F
0078:  MOVWF  2D
....................       lcd.enable = 0; 
0079:  BCF    06.0
....................       delay_cycles(1); 
007A:  NOP
....................       lcd.enable = 1; 
007B:  BSF    06.0
....................       delay_us(1); 
....................       low = lcd.data; 
007C:  MOVF   06,W
007D:  SWAPF  06,W
007E:  ANDLW  0F
007F:  MOVWF  2C
....................       lcd.enable = 0; 
0080:  BCF    06.0
....................       set_tris_lcd(LCD_WRITE); 
0081:  MOVLW  00
0082:  BSF    03.5
0083:  MOVWF  06
....................       return( (high<<4) | low); 
0084:  BCF    03.5
0085:  SWAPF  2D,W
0086:  MOVWF  77
0087:  MOVLW  F0
0088:  ANDWF  77,F
0089:  MOVF   77,W
008A:  IORWF  2C,W
008B:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
0061:  SWAPF  2D,W
0062:  ANDLW  F0
0063:  MOVWF  77
0064:  MOVLW  0F
0065:  ANDWF  06,W
0066:  IORWF  77,W
0067:  MOVWF  06
....................       delay_cycles(1); 
0068:  NOP
....................       lcd.enable = 1; 
0069:  BSF    06.0
....................       delay_us(2); 
....................       lcd.enable = 0; 
006A:  BCF    06.0
.................... } 
006B:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
006C:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
008C:  MOVF   78,W
008D:  MOVWF  2C
008E:  BTFSC  2C.7
008F:  GOTO   06D
....................       lcd.rs = address; 
0090:  BTFSS  2A.0
0091:  BCF    06.1
0092:  BTFSC  2A.0
0093:  BSF    06.1
....................       delay_cycles(1); 
0094:  NOP
....................       lcd.rw = 0; 
0095:  BCF    06.2
....................       delay_cycles(1); 
0096:  NOP
....................       lcd.enable = 0; 
0097:  BCF    06.0
....................       lcd_send_nibble(n >> 4); 
0098:  SWAPF  2B,W
0099:  MOVWF  2C
009A:  MOVLW  0F
009B:  ANDWF  2C,F
009C:  MOVF   2C,W
009D:  MOVWF  2D
009E:  CALL   061
....................       lcd_send_nibble(n & 0xf); 
009F:  MOVF   2B,W
00A0:  ANDLW  0F
00A1:  MOVWF  2C
00A2:  MOVWF  2D
00A3:  CALL   061
.................... } 
00A4:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     set_tris_lcd(LCD_WRITE); 
00A5:  MOVLW  00
00A6:  BSF    03.5
00A7:  MOVWF  06
....................     lcd.rs = 0; 
00A8:  BCF    03.5
00A9:  BCF    06.1
....................     lcd.rw = 0; 
00AA:  BCF    06.2
....................     lcd.enable = 0; 
00AB:  BCF    06.0
....................     delay_ms(15); 
00AC:  MOVLW  0F
00AD:  MOVWF  25
00AE:  CALL   054
....................     for(i=1;i<=3;++i) { 
00AF:  MOVLW  01
00B0:  MOVWF  24
00B1:  MOVF   24,W
00B2:  SUBLW  03
00B3:  BTFSS  03.0
00B4:  GOTO   0BD
....................        lcd_send_nibble(3); 
00B5:  MOVLW  03
00B6:  MOVWF  2D
00B7:  CALL   061
....................        delay_ms(5); 
00B8:  MOVLW  05
00B9:  MOVWF  25
00BA:  CALL   054
....................     } 
00BB:  INCF   24,F
00BC:  GOTO   0B1
....................     lcd_send_nibble(2); 
00BD:  MOVLW  02
00BE:  MOVWF  2D
00BF:  CALL   061
....................     for(i=0;i<=3;++i) 
00C0:  CLRF   24
00C1:  MOVF   24,W
00C2:  SUBLW  03
00C3:  BTFSS  03.0
00C4:  GOTO   0CE
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
00C5:  MOVF   24,W
00C6:  CALL   004
00C7:  MOVWF  25
00C8:  CLRF   2A
00C9:  MOVF   25,W
00CA:  MOVWF  2B
00CB:  CALL   06C
00CC:  INCF   24,F
00CD:  GOTO   0C1
.................... } 
00CE:  BCF    0A.3
00CF:  BCF    0A.4
00D0:  GOTO   122 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
00D4:  DECFSZ 27,W
00D5:  GOTO   0D7
00D6:  GOTO   0DA
....................      address=lcd_line_two; 
00D7:  MOVLW  40
00D8:  MOVWF  28
....................    else 
00D9:  GOTO   0DB
....................      address=0; 
00DA:  CLRF   28
....................    address+=x-1; 
00DB:  MOVLW  01
00DC:  SUBWF  26,W
00DD:  ADDWF  28,F
....................    lcd_send_byte(0,0x80|address); 
00DE:  MOVF   28,W
00DF:  IORLW  80
00E0:  MOVWF  29
00E1:  CLRF   2A
00E2:  MOVF   29,W
00E3:  MOVWF  2B
00E4:  CALL   06C
.................... } 
00E5:  RETLW  00
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
00E6:  MOVF   25,W
00E7:  XORLW  0C
00E8:  BTFSC  03.2
00E9:  GOTO   0F1
00EA:  XORLW  06
00EB:  BTFSC  03.2
00EC:  GOTO   0FB
00ED:  XORLW  02
00EE:  BTFSC  03.2
00EF:  GOTO   101
00F0:  GOTO   106
....................      case '\f'   : lcd_send_byte(0,1); 
00F1:  CLRF   2A
00F2:  MOVLW  01
00F3:  MOVWF  2B
00F4:  CALL   06C
....................                    delay_ms(2); 
00F5:  MOVLW  A6
00F6:  MOVWF  77
00F7:  DECFSZ 77,F
00F8:  GOTO   0F7
00F9:  NOP
....................                                            break; 
00FA:  GOTO   10C
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
00FB:  MOVLW  01
00FC:  MOVWF  26
00FD:  MOVLW  02
00FE:  MOVWF  27
00FF:  CALL   0D4
0100:  GOTO   10C
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0101:  CLRF   2A
0102:  MOVLW  10
0103:  MOVWF  2B
0104:  CALL   06C
0105:  GOTO   10C
....................      default     : lcd_send_byte(1,c);     break; 
0106:  MOVLW  01
0107:  MOVWF  2A
0108:  MOVF   25,W
0109:  MOVWF  2B
010A:  CALL   06C
010B:  GOTO   10C
....................    } 
.................... } 
010C:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #include <kbd1.c>            // Incluimos el driver kbd1.c que contiene las funciones de control del Teclado. 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBDD.C                                //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
....................  
.................... #if defined(__PCH__) 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 0xF81                   // This puts the entire structure 
.................... #else 
....................    #byte kbd = 0xF82                   // This puts the entire structure 
.................... #endif 
.................... #else 
.................... #if defined use_portb_kbd 
....................    #byte kbd = 6                  // on to port B (at address 6) 
.................... #else 
....................    #byte kbd = 7                 // on to port C (at address 7) 
.................... #endif 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_c(x) 
.................... #endif 
....................  
....................  
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
.................... } 
*
00D1:  BCF    0A.3
00D2:  BCF    0A.4
00D3:  GOTO   123 (RETURN)
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
0116:  BCF    03.5
0117:  CLRF   20
....................    static short int kbd_down; 
0118:  BCF    21.0
....................    static char last_key; 
0119:  CLRF   22
....................    static BYTE col; 
011A:  CLRF   23
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
....................        switch (col) { 
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
....................                     kbd=~COL0&ALL_PINS; 
....................                     break; 
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
....................                     kbd=~COL1&ALL_PINS; 
....................                     break; 
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
....................                     kbd=~COL2&ALL_PINS; 
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
....................            kbd_down=FALSE; 
....................            kchar=last_key; 
....................            last_key='\0'; 
....................          } 
....................        } else { 
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
....................              if((kbd & ROW0)==0) 
....................                row=0; 
....................              else if((kbd & ROW1)==0) 
....................                row=1; 
....................              else if((kbd & ROW2)==0) 
....................                row=2; 
....................              else if((kbd & ROW3)==0) 
....................                row=3; 
....................              last_key =KEYS[row][col]; 
....................              kbd_down = TRUE; 
....................           } else { 
....................              ++col; 
....................              if(col==3) 
....................                col=0; 
....................           } 
....................        } 
....................       kbd_call_count=0; 
....................    } 
....................   set_tris_kbd(ALL_PINS); 
....................   return(kchar); 
.................... } 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.141592654 
....................  
....................  
.................... #define SQRT2  1.41421356 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float CEIL_FLOOR(float x, int n) 
.................... { 
....................    float y, res; 
....................    long l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float)(long)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (long)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float)l); 
....................   res = 32768.0*(float)l; 
....................   res += (float)(long)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float)(long)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float floor(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float ceil(float x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //	float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float x,float y) 
.................... { 
....................    float i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
....................  
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
....................  
.................... #define LN2 0.6931471806 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... float exp(float x) 
.................... { 
....................    float y, res, r; 
....................    signed int n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed long)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................    *(&res) = n + 0x7F; 
....................  
....................    y = y/LN2 - (float)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... /************************************************************/ 
....................  
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float log(float x) 
.................... { 
....................    float y, res, r, y2; 
....................    signed n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................       *(&y) = 0x7E; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................       n = *(&x) - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float)-n; 
....................       else 
....................          r = (float)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... #define LN10 2.30258509 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float log10(float x) 
.................... { 
....................    float r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float modf(float value,float *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pwr(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // 
.................... float pow(float x,float y) 
.................... { 
....................    if(x>=0) 
....................      return(  exp(y*log(x)) ); 
....................    else 
....................      return(  -exp(y*log(-x)) ); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float sqrt(float x) 
.................... { 
....................    float y, res; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p=&y; 
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1); 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................       (*p)--; 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO	1.570796326794896 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI 			0.6366197724 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float cos(float x) 
.................... { 
.................... 	float y, t, t2 = 1.0; 
.................... 	int quad, i; 
.................... 	float frac; 
.................... 	float p[4] = { 
.................... 		-0.499999993585, 
.................... 		 0.041666636258, 
.................... 		-0.0013888361399, 
.................... 		 0.00002476016134 
.................... 	}; 
....................  
.................... 	if (x < 0) x = -x;                  // absolute value of input 
....................  
.................... 	quad = (int)(x / PI_DIV_BY_TWO);    // quadrant 
.................... 	frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
.................... 	quad = quad % 4;                    // quadrant (0 to 3) 
....................  
.................... 	if (quad == 0 || quad == 2) 
.................... 		t = frac * PI_DIV_BY_TWO; 
.................... 	else if (quad == 1) 
.................... 		t = (1-frac) * PI_DIV_BY_TWO; 
.................... 	else // should be 3 
.................... 		t = (frac-1) * PI_DIV_BY_TWO; 
....................  
.................... 	y = 0.999999999781; 
.................... 	t = t * t; 
.................... 	for (i = 0; i <= 3; i++) 
.................... 	{ 
.................... 		t2 = t2 * t; 
.................... 		y = y + p[i] * t2; 
.................... 	} 
....................  
.................... 	if (quad == 2 || quad == 1) 
.................... 		y = -y;  // correct sign 
....................  
.................... 	return (y); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float sin(float x) 
.................... { 
.................... 	return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float tan(float x) 
.................... { 
....................    float c, s; 
....................  
....................    c = cos(x); 
.................... 	if (c == 0.0) 
.................... 	   return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
....................  
....................  
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float ASIN_COS(float x, int n) 
.................... { 
....................    float y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float asin(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float acos(float x) 
.................... { 
....................    float r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float atan(float x) 
.................... { 
....................    float y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //	float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
....................  
.................... float atan2(float y,float x) 
.................... { 
....................    float z; 
....................    int1 sign; 
....................    int quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float cosh(float x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float sinh(float x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float tanh(float x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //	float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
....................  
....................  
.................... #define LOG2 .30102999566398119521 
.................... float frexp(float x, signed int *exp) 
.................... { 
....................    float res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //	float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float ldexp(float value, signed int exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #BYTE TRISC = 0x87               // TRISC en 87h. 
.................... #BYTE portC = 0x07               // PORTC en 07h. 
.................... #BYTE TRISA = 0x85               // TRISB en 86h. 
.................... #BYTE portA = 0x05               // PORTB en 06h. 
.................... #BIT rc0 = 0x07.0  
.................... #BIT rc1 = 0x07.1 
.................... #BIT rc2 = 0x07.2 
.................... #BIT rc5 = 0x07.5 
.................... #BIT ra0 = 0x05.0 
.................... #BIT ra1 = 0x05.1 
.................... #BIT ra2 = 0x05.2 
.................... #BIT ra3 = 0x05.3 
.................... #BIT ra4 = 0x05.4 
.................... #BIT ra5 = 0x05.5 
....................  
....................  
....................   
....................  
.................... void main() 
....................  
.................... { 
*
010D:  CLRF   04
010E:  BCF    03.7
010F:  MOVLW  1F
0110:  ANDWF  03,F
0111:  BSF    03.5
0112:  BSF    1F.0
0113:  BSF    1F.1
0114:  BSF    1F.2
0115:  BCF    1F.3
....................    TRISC= 0B00000000; 
*
011B:  BSF    03.5
011C:  CLRF   07
....................    TRISA= 0B001011; 
011D:  MOVLW  0B
011E:  MOVWF  05
....................    portC= 0B00000000; 
011F:  BCF    03.5
0120:  CLRF   07
....................    //setup_timer_2(T2_DIV_BY_16,249,1);           // setup_timer(Prescaler,PR2,Postscaler) 
....................                      // Configuracin timer2. Si el Periodo = 16mS ----> T = 16000uS 
....................                      // T = [PR2+1] x Tcm x Postscaler x Prescaler 
....................                      // PR2 puede valer de 0 a 255. 
....................                      // Tcm es el tiempo de Ciclo Maquina.  Tcm = 4/Fosc = 4/1.000.000 hz = 4uS. 
....................                      // Prescaler puede valer 1,4,16 
....................                      // Postscaler puede valer 1. 
....................                      // 16000uS = [PR2+1] x 4 x 16 x 1 
....................  
....................                      // PR2 =[T/(Tcm x Preescaler x Postscaler)]-1 
....................                      // PR2 =[16000uS/(4uS x 16 x 1)]-1 = 249          (en C 249) 
....................     
....................     
....................    //setup_ccp2(CCP_PWM);                         // CCP2 en modo PWM (Salida por RC1) 
....................    //setup_ccp1(CCP_PWM);                         // CCP1 en modo PWM (Salida por RC2) 
....................     
....................  
....................  
....................    lcd_init();             // Inicializamos el LCD. 
0121:  GOTO   0A5
....................    kbd_init();              // Inicializamos el Teclado. 
0122:  GOTO   0D1
....................  
....................    port_b_pullups(TRUE);          // Habilitamos las Resistencias pull up inernas en el puerto B 
0123:  BSF    03.5
0124:  BCF    01.7
....................     
....................     
....................    while(1){ 
....................             rc2=0; 
0125:  BCF    03.5
0126:  BCF    07.2
....................             rc1=0; 
0127:  BCF    07.1
....................             lcd_gotoxy(1,1); 
0128:  MOVLW  01
0129:  MOVWF  26
012A:  MOVWF  27
012B:  CALL   0D4
....................             printf(lcd_putc, "Mod Prue.Motor", ); 
012C:  CLRF   24
012D:  MOVF   24,W
012E:  CALL   00C
012F:  INCF   24,F
0130:  MOVWF  77
0131:  MOVWF  25
0132:  CALL   0E6
0133:  MOVLW  0E
0134:  SUBWF  24,W
0135:  BTFSS  03.2
0136:  GOTO   12D
....................             rc5=0; 
0137:  BCF    07.5
....................             ra2=0; 
0138:  BCF    05.2
....................             rc0=0; 
0139:  BCF    07.0
....................             ra4=0; 
013A:  BCF    05.4
....................             //set_pwm1_duty(1000); 
....................             //set_pwm2_duty(1000); 
....................             delay_ms(2000); 
013B:  MOVLW  08
013C:  MOVWF  24
013D:  MOVLW  FA
013E:  MOVWF  25
013F:  CALL   054
0140:  DECFSZ 24,F
0141:  GOTO   13D
....................             lcd_gotoxy(1,2); 
0142:  MOVLW  01
0143:  MOVWF  26
0144:  MOVLW  02
0145:  MOVWF  27
0146:  CALL   0D4
....................             printf(lcd_putc, "\fMot. Izq", ); 
0147:  CLRF   24
0148:  MOVF   24,W
0149:  CALL   01F
014A:  INCF   24,F
014B:  MOVWF  77
014C:  MOVWF  25
014D:  CALL   0E6
014E:  MOVLW  09
014F:  SUBWF  24,W
0150:  BTFSS  03.2
0151:  GOTO   148
....................             rc5=1; 
0152:  BSF    07.5
....................             ra2=0; 
0153:  BCF    05.2
....................             rc0=0; 
0154:  BCF    07.0
....................             ra4=0; 
0155:  BCF    05.4
....................             //set_pwm1_duty(1000); 
....................             //set_pwm2_duty(0); 
....................             delay_ms(4000); 
0156:  MOVLW  10
0157:  MOVWF  24
0158:  MOVLW  FA
0159:  MOVWF  25
015A:  CALL   054
015B:  DECFSZ 24,F
015C:  GOTO   158
....................             lcd_gotoxy(1,2); 
015D:  MOVLW  01
015E:  MOVWF  26
015F:  MOVLW  02
0160:  MOVWF  27
0161:  CALL   0D4
....................             printf(lcd_putc, "\fMot. Der", ); 
0162:  CLRF   24
0163:  MOVF   24,W
0164:  CALL   02D
0165:  INCF   24,F
0166:  MOVWF  77
0167:  MOVWF  25
0168:  CALL   0E6
0169:  MOVLW  09
016A:  SUBWF  24,W
016B:  BTFSS  03.2
016C:  GOTO   163
....................             rc5=0; 
016D:  BCF    07.5
....................             ra2=0; 
016E:  BCF    05.2
....................             rc0=1; 
016F:  BSF    07.0
....................             ra4=0; 
0170:  BCF    05.4
....................             //set_pwm1_duty(0); 
....................             //set_pwm2_duty(1000);       
....................             delay_ms(4000); 
0171:  MOVLW  10
0172:  MOVWF  24
0173:  MOVLW  FA
0174:  MOVWF  25
0175:  CALL   054
0176:  DECFSZ 24,F
0177:  GOTO   173
....................             lcd_gotoxy(1,2); 
0178:  MOVLW  01
0179:  MOVWF  26
017A:  MOVLW  02
017B:  MOVWF  27
017C:  CALL   0D4
....................             printf(lcd_putc, "\fAdelante", ); 
017D:  CLRF   24
017E:  MOVF   24,W
017F:  CALL   03B
0180:  INCF   24,F
0181:  MOVWF  77
0182:  MOVWF  25
0183:  CALL   0E6
0184:  MOVLW  09
0185:  SUBWF  24,W
0186:  BTFSS  03.2
0187:  GOTO   17E
....................             rc5=1; 
0188:  BSF    07.5
....................             ra2=0; 
0189:  BCF    05.2
....................             rc0=1; 
018A:  BSF    07.0
....................             ra4=0; 
018B:  BCF    05.4
....................             //set_pwm1_duty(0); 
....................             set_pwm2_duty(0);             
018C:  CLRF   1B
....................             delay_ms(4000); 
018D:  MOVLW  10
018E:  MOVWF  24
018F:  MOVLW  FA
0190:  MOVWF  25
0191:  CALL   054
0192:  DECFSZ 24,F
0193:  GOTO   18F
....................             lcd_gotoxy(1,2); 
0194:  MOVLW  01
0195:  MOVWF  26
0196:  MOVLW  02
0197:  MOVWF  27
0198:  CALL   0D4
....................             printf(lcd_putc, "\fAtras", ); 
0199:  CLRF   24
019A:  MOVF   24,W
019B:  CALL   049
019C:  INCF   24,F
019D:  MOVWF  77
019E:  MOVWF  25
019F:  CALL   0E6
01A0:  MOVLW  06
01A1:  SUBWF  24,W
01A2:  BTFSS  03.2
01A3:  GOTO   19A
....................             rc5=0; 
01A4:  BCF    07.5
....................             ra2=1; 
01A5:  BSF    05.2
....................             rc0=0; 
01A6:  BCF    07.0
....................             ra4=1; 
01A7:  BSF    05.4
....................             //set_pwm1_duty(512); 
....................             //set_pwm2_duty(512);  
....................             delay_ms(4000); 
01A8:  MOVLW  10
01A9:  MOVWF  24
01AA:  MOVLW  FA
01AB:  MOVWF  25
01AC:  CALL   054
01AD:  DECFSZ 24,F
01AE:  GOTO   1AA
....................              
....................  
....................  
....................   
....................     } 
01AF:  GOTO   126
....................                           
.................... } 
....................  
01B0:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NOPROTECT BROWNOUT NOLVP NOCPD NOWRT NODEBUG
